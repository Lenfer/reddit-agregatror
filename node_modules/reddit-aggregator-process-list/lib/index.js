'use strict';

const _ = require('lodash');
const moment = require('moment');


/**
 * Конструктор
 */
function ProcessList(options) {
	_.merge(this, options);
}




/**
 * Извлечение поля из записи по его описанию
 * @param {Object} item Запись в списке
 * @param {Object} fieldShema Описание извлечения поля
 * @returns {Any}
 * @private
 */
ProcessList.prototype._extractFieldByShema = function(item, fieldShema) {
	// Если описание поля это строка сразу вернем значение
	if (_.isString(fieldShema)) {
		return _.get(item, fieldShema);
	}
	let value = _.get(item, fieldShema.path);
	let transform = fieldShema.transform;
	// Если в поле трансформации поля указана строка попытаемся найти
	// ее в уже определенных методах с префиксом fieldTransform
	if (_.isString(transform)) {
		var methodName = _.camelCase('fieldTransform ' + transform);
		value = this[methodName] ? this[methodName](value, fieldShema, item) : value;
	}
	// Если в поле трансформации указана функция выполним ее и вернем результат
	if (_.isFunction(transform)) {
		value = transform(value, fieldShema, item);
	}
	return value;
};



/**
 * Трансформация записи по описанию
 * @param {Object} item Запись в списке
 * @param {Object[]|String[]} shema Описание трансформации
 * @returns {Object}
 * @private
 */
ProcessList.prototype._transformItemBy = function(item, shema) {
	return _.reduce(shema, (result, fieldShema, pathDest) => {
		_.set(result, pathDest, this._extractFieldByShema(item, fieldShema, pathDest));
		return result;
	}, {});
};



/**
 * Трансформация каждой записи в списке по описанию
 * @param {Object} shema Описание
 * @returns {ProcessList}
 */
ProcessList.prototype.transformBy = function(shema) {
	var result = _.reduce(this._list, (result, item) => {
		result.push(this._transformItemBy(item, shema));
		return result;
	}, []);
	this._list = result;
	return this;
};


/**
 * Сравнение двух записей для сортировки
 * @param {String} path Путь к полю
 * @param {Object} a Запись в списке
 * @param {Object} b Запись в списке
 * @returns {Number}
 * @private
 */
ProcessList.prototype._primitiveComparator = function(path, a, b) {
	let af = _.get(a, path);
	let bf = _.get(b, path);
	if (af > bf) {
		return -1;
	}
	if (af < bf) {
		return 1;
	}
	return 0;
};


/**
 * Сортировка списка по полю
 * @param {String} path Путь к полю
 * @param {String} [sortingOrder=asc] Тип сортировки (asc/desc)
 * @returns {ProcessList}
 */
ProcessList.prototype.sortBy = function(path, sortingOrder) {
	let isDesc = (sortingOrder === 'desc');
	this._list.sort((a, b) => {
		var result = this._primitiveComparator(path, a, b);
		return isDesc ? result : -result;
	});
	return this;
};


/**
 * Сгруппировать список
 * @param {String} groupFieldPath Путь к полю по которому будем групировать
 * @param {Object} shema Схема группировки
 * @returns {ProcessList}
 */
ProcessList.prototype.groupBy = function(groupFieldPath, shema) {
	let result = _.reduce(this._list, (result, item) => {
		let gfield = _.get(item, groupFieldPath);
		result[gfield] = this._aggregateByShema(result[gfield], item, shema);
		return result;
	}, {});
	this._list = _.toArray(result);
	return this;
};

/**
 * Добавление в группу одной записи
 * @param {Object} resultItem Запись в сгруппированном списке
 * @param {Object} item Запись из списка
 * @param {Object} shema Схема группировки
 * @returns {Object}
 * @private
 */
ProcessList.prototype._aggregateByShema = function(resultItem, item, shema) {
	return _.reduce(shema, (resultItem, fieldShema, destPath) => {
		// Если передана строка то не надо ничего делать, просто присваиваем
		if (_.isString(fieldShema)) {
			let value = _.get(item, fieldShema);
			_.set(resultItem, destPath, value);
			return resultItem;
		}
		let aggregate = fieldShema.aggregate;
		// Если в поле агрегации указана строка попытаемся найти
		// ее в уже определенных методах с префиксом fieldAggregate
		if (_.isString(aggregate)) {
			var methodName = _.camelCase('fieldAggregate ' + aggregate);
			// Если метод существует
			if (this[methodName]) {
				this[methodName](resultItem, fieldShema, destPath, item);
			}
		}
		// Если в поле агрегации указана функция выполним ее
		if (_.isFunction(aggregate)) {
			aggregate(resultItem, fieldShema, destPath, item);
		}
		return resultItem;
	}, resultItem || {});
};



/**
 * Преобразование timestapm в формат заданный полем fieldShem.format
 * @param {String} value Timestamp
 * @param {Object} fieldShema Описание извлечения поля
 * @param {Object} item Запись в списке
 * @returns {String}
 */
ProcessList.prototype.fieldTransformUtcTime = function(value, fieldShema, item) {
	return moment(value, 'X').format(fieldShema.format || 'YYYY-MM-DD HH:mm:ss');
};


/**
 * Добавляет значение в агрегированную запись
 * @param {Object} resultItem Запись агрегации
 * @param {Object} fieldShema Описание извлечения поля
 * @param {Object} destPath Путь до поля назначения
 * @param {Object} item Запись в списке
 */
ProcessList.prototype.fieldAggregateSum = function(resultItem, fieldShema, destPath, item) {
	let path = fieldShema.path;
	let value = _.get(resultItem, destPath, 0);
	let addValue = _.get(item, path, 0);
	_.set(resultItem, destPath, value + addValue);
};

/**
 * Добавляет значение в агрегированную запись
 * @param {Object} resultItem Запись агрегации
 * @param {Object} fieldShema Описание извлечения поля
 * @param {Object} destPath Путь до поля назначения
 * @param {Object} item Запись в списке
 */
ProcessList.prototype.fieldAggregateCount = function(resultItem, fieldShema, destPath, item) {
	let value = _.get(resultItem, destPath, 0);
	_.set(resultItem, destPath, ++value);
};


/**
 * Установить значене списка для обработки
 * @param {Object[]} data Список
 * @returns {ProcessList}
 */
ProcessList.prototype.list = function(data) {
	this._list = data;
	return this;
};

/**
 * Получить текущий список
 * @returns {Object[]}
 */
ProcessList.prototype.get = function() {
	return this._list;
};


module.exports = ProcessList;
