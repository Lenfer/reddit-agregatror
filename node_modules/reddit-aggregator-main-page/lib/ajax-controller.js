'use strict';

const _ = require('lodash');
const Vow = require('vow');

const sourceManager = require('reddit-aggregator-source-manager');
const ProcessList = require('reddit-aggregator-process-list');
const log = require('reddit-aggregator-logger')('main-page');

const converter = require('./convert-to-format');

const shema = {
	id: 'data.id',
	title: 'data.title',
	created: {
		path: 'data.created_utc',
		transform: 'utc-time'
	},
	score: 'data.score'
};

let fieldMap = {
	id: 'id',
	title: 'title',
	created: 'created',
	score: 'score'
};


let fieldMapAggregate = {
	domain: 'domain',
	articles: 'articles',
	score: 'score'
};


module.exports = (req, res) => {
	const query = req.body;
	sourceManager
		.get({
			req: req,
			category: 'javascript'
		})
		.then((redditData) => {
			try {
				redditData = JSON.parse(redditData);
			} catch (e) {
				log.error(req, 'Wrong JSON format', redditData);
				return Vow.rejected();
			}

			// Создаем объект для преобразования данных
			let plist = new ProcessList();

			plist.list(_.get(redditData, 'data.children', []));

			let sqlMap;

			// Преобразуем данные
			switch (query.transform) {
				case 'sort-by-date':
					plist
						.transformBy(shema)
						.sortBy('created', query.sortOrder);
					sqlMap = fieldMap;
					break;

				case 'sort-by-rating':
					plist
						.transformBy(shema)
						.sortBy('score', query.sortOrder);
					sqlMap = fieldMap;
					break;

				case 'group-by-domens':
					plist
						.groupBy('data.domain', {
							domain: 'data.domain',
							articles: {
								aggregate: 'count'
							},
							score: {
								path: 'data.score',
								aggregate: 'sum'
							}
						})
						.sortBy('articles', 'desc');

					sqlMap = fieldMapAggregate;
					break;
				default:
					log.error(req, 'Unknown transform type', query.transform);
					return Vow.rejected();
			}

			// Получим список
			let resList = plist.get();

			if (!resList.length) {
				return res.send('No data.');
			}



			// Преобразуем в нужный формат
			let output = converter(query.format, resList, _.defaults(query, {
				log: log,
				req: req,
				csvDelemiter: ';',
				fieldMap: sqlMap,
				tableName: 'testTableName'
			}));

			// Отправляем ответ пользователю
			res.send(output);
		})
		.fail(() => {
			res.status(500).send('Что-то пошло не так!');
		})
};

